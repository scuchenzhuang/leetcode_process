统计所有小于非负整数 n 的质数的数量。

示例:

输入: 10
输出: 4
解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。
细究暴力计算的方法，我们可以发现，假如一个数为 9 ，那么其二分之一（4.5）后的数都可以不用进行计算，因为肯定是有余的 。事实上情况会比这更好一些：对正整数 n ，如果用 2 到 √n 之间(包含边界)的所有整数去除，均无法整除，则 n 为质数。

并且，我们可以发现，一切非 2 偶数一定不可能为质数。所以，我们可以在此处进行另一步的优化。

有个这些令人庆幸的发现，我们的代码也将如虎添翼：

csharpcpp
public int CountPrimes(int n)
{
    if(n < 3)
        return 0;;
    //从3开始验算，所以初始值为1（2为质数）。
    int count = 1;
    for (int i = 3; i < n; i++)
    {
        //当某个数为 2 的 n 次方时（n为自然数），其 & (n - 1) 所得值将等价于取余运算所得值
        //*如果 x = 2^n ，则 x & (n - 1) == x % n
        //if(i % 2 == 0)
        if ((i & 1) == 0)
            continue; ;
        bool sign = true;
        //用 j * j <= i 代替 j <= √i 会更好。
        //因为我们已经排除了所有偶数，所以每次循环加二将规避偶数会减少循环次数
        for (int j = 3; j * j <=i; j+=2)
        {
            if (i % j == 0)
            {
                sign = false;
                break;
            }
        }
        if (sign)
            count++; ;
    }
    return count;
}
(暴力法系列的 C# 和 C++ 的代码几乎相同。)

经过对暴力算法的此番优化，我们的代码初步达到了应用的最低门槛，但显然还是不大理想，好似总感觉存在不必要的操作。但我们经过以上的研究（可以早一步排除偶数），再结合质数的性质，可以推想出：如果我们在进行顺序遍历时，每取得一个数（排除0、1），如果将它所有的倍数（排除0、1、本身）都清除，那么，剩下的数是不是必为素数？
对此，我们可以声明一个长度为最大限制数的布尔数组。用布尔值来区别筛选出的数和质数。

运用厄拉多塞筛法得代码如下：

int countPrimes(int n) {
    int count = 0;
    //初始默认所有数为质数
    vector<bool> signs(n, true);
    for (int i = 2; i < n; i++) {
        if (signs[i]) {
            count++;
            for (int j = i + i; j < n; j += i) {
                //排除不是质数的数
                signs[j] = false;
            }
        }
    }
    return count;
}

